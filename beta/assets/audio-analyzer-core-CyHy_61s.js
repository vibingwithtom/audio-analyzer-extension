class H{constructor(){this.audioContext=null,this.audioBuffer=null}async analyzeFile(t){const e=await t.arrayBuffer();if(t.name.toLowerCase().endsWith(".wav")){const a=new DataView(e),o=this.parseWavHeaders(a);let n=this.getFileType(t.name);return n==="WAV"&&(o.audioFormat===1?n="WAV (PCM)":typeof o.audioFormat=="number"?n=`WAV (Compressed - Format ${o.audioFormat})`:n="WAV (Unknown Format)"),{fileType:n,sampleRate:o.sampleRate,channels:o.channels,bitDepth:o.bitDepth,duration:o.duration,fileSize:t.size}}this.audioContext||(this.audioContext=new(window.AudioContext||window.webkitAudioContext));try{const a=e.slice(0);return this.audioBuffer=await this.audioContext.decodeAudioData(a),{fileType:this.getFileType(t.name),sampleRate:this.audioBuffer.sampleRate,channels:this.audioBuffer.numberOfChannels,duration:this.audioBuffer.duration,fileSize:t.size,bitDepth:this.estimateBitDepth(e,t.name)}}catch{return await this.analyzeFileHeaders(e,t.name,t.size)}}async analyzeFileHeaders(t,e,a){const o=new DataView(t),n={fileType:this.getFileType(e),fileSize:a};if(e.toLowerCase().endsWith(".wav")){const h=this.parseWavHeaders(o);Object.assign(n,h)}else n.sampleRate="Unknown",n.bitDepth="Unknown",n.channels="Unknown",n.duration="Unknown";return n}parseWavHeaders(t){try{if(String.fromCharCode(t.getUint8(0),t.getUint8(1),t.getUint8(2),t.getUint8(3))!=="RIFF")throw new Error("Not a valid WAV file");if(String.fromCharCode(t.getUint8(8),t.getUint8(9),t.getUint8(10),t.getUint8(11))!=="WAVE")throw new Error("Not a valid WAV file");let o=12;for(;o<t.byteLength-8;){const n=String.fromCharCode(t.getUint8(o),t.getUint8(o+1),t.getUint8(o+2),t.getUint8(o+3)),h=t.getUint32(o+4,!0);if(n==="fmt "){const r=t.getUint16(o+8,!0),f=t.getUint16(o+10,!0),c=t.getUint32(o+12,!0),i=t.getUint16(o+22,!0),l=this.calculateWavDuration(t,c,f,i);return{sampleRate:c,channels:f,bitDepth:i,duration:l,audioFormat:r}}o+=8+h}throw new Error("fmt chunk not found")}catch(e){return console.error("Error parsing WAV headers:",e),{sampleRate:"Unknown",channels:"Unknown",bitDepth:"Unknown",duration:"Unknown",audioFormat:"Unknown"}}}calculateWavDuration(t,e,a,o){try{let n=12;for(;n<t.byteLength-8;){const h=String.fromCharCode(t.getUint8(n),t.getUint8(n+1),t.getUint8(n+2),t.getUint8(n+3)),r=t.getUint32(n+4,!0);if(h==="data"){const f=o/8;return r/(a*f)/e}n+=8+r}return"Unknown"}catch{return"Unknown"}}getFileType(t){const e=t.split(".").pop().toLowerCase();return{wav:"WAV",mp3:"MP3",flac:"FLAC",aac:"AAC",m4a:"M4A",ogg:"OGG",webm:"WebM"}[e]||e.toUpperCase()}estimateBitDepth(t,e){if(e.toLowerCase().endsWith(".wav"))return"See WAV analysis";const a=e.split(".").pop().toLowerCase();return["mp3","aac","m4a"].includes(a)?"Compressed (variable)":"Unknown"}}class V{static matchesFileType(t,e){const a={matches:!1,status:"fail"};if(t===e)return a.matches=!0,a.status="pass",a;if(e==="wav"||e==="WAV")return t==="WAV (PCM)"||t==="WAV"?(a.matches=!0,a.status="pass",a):(t.startsWith("WAV")&&(a.matches=!0,a.status="warning"),a);const o=t.replace(/\s*\(.*\)/,"").trim(),n=e.toUpperCase();return o===n&&(a.matches=!0,a.status="pass"),a}static validateResults(t,e,a=!1){const o={},n=r=>r?Array.isArray(r)?r:[r]:[],h=n(e.fileType);if(h.length>0){let r={matches:!1,status:"fail"};for(const f of h){const c=this.matchesFileType(t.fileType,f);if(c.status==="pass"){r=c;break}else c.status==="warning"&&r.status==="fail"&&(r=c)}o.fileType={matches:r.matches,target:h,actual:t.fileType,status:r.status}}if(!a){const r=n(e.sampleRate).map(i=>parseInt(i)).filter(i=>!isNaN(i));if(r.length>0){const i=t.sampleRate;let l,s;i==="Unknown"||typeof i!="number"?(s=!1,l="warning"):(s=r.includes(i),l=s?"pass":"fail"),o.sampleRate={matches:s,target:r,actual:i,status:l}}const f=n(e.bitDepth).map(i=>parseInt(i)).filter(i=>!isNaN(i));if(f.length>0){const i=t.bitDepth;let l,s;i==="Unknown"||typeof i!="number"?(s=!1,l="warning"):(s=f.includes(i),l=s?"pass":"fail"),o.bitDepth={matches:s,target:f,actual:i,status:l}}const c=n(e.channels).map(i=>parseInt(i)).filter(i=>!isNaN(i));if(c.length>0){const i=t.channels;let l,s;i==="Unknown"||typeof i!="number"?(s=!1,l="warning"):(s=c.includes(i),l=s?"pass":"fail"),o.channels={matches:s,target:c,actual:i,status:l}}if(e.minDuration){const i=parseInt(e.minDuration),l=t.duration;let s,p;l==="Unknown"||typeof l!="number"?(p=!1,s="warning"):(p=l>=i,s=p?"pass":"fail"),o.duration={matches:p,target:`${i}s minimum`,actual:l,status:s}}}return o}static formatDuration(t){const e=Math.floor(t/3600),a=Math.floor(t%3600/60),o=Math.floor(t%60);return e>0?`${e}h:${a.toString().padStart(2,"0")}m:${o.toString().padStart(2,"0")}s`:`${a}m:${o.toString().padStart(2,"0")}s`}static formatDisplayText(t){const e={};return e.fileType=t.fileType,e.sampleRate=typeof t.sampleRate=="number"?`${(t.sampleRate/1e3).toFixed(1)} kHz`:t.sampleRate,e.bitDepth=typeof t.bitDepth=="number"?`${t.bitDepth}-bit`:t.bitDepth,e.channels=typeof t.channels=="number"?`${t.channels}${t.channels===1?" (Mono)":t.channels===2?" (Stereo)":""}`:t.channels,e.duration=typeof t.duration=="number"?this.formatDuration(t.duration):t.duration,e.fileSize=`${(t.fileSize/1024/1024).toFixed(2)} MB`,e}static formatAdvancedResults(t){const e={};return e.peakLevel=t.peakDb===-1/0?"Silent":`${t.peakDb.toFixed(1)} dB`,e.peakStatus=t.peakDb<=-6?"pass":t.peakDb<=-3?"warning":"fail",e.noiseFloor=t.noiseFloorDb===-1/0?"Silent":`${t.noiseFloorDb.toFixed(1)} dB`,e.noiseStatus=t.noiseFloorDb<=-60?"pass":"fail",e.normalization=t.normalizationStatus.message,e.normalizationStatus=t.normalizationStatus.status==="normalized"?"pass":"fail",e}}class L{constructor(){this.analysisInProgress=!1}async analyzeAudioBuffer(t,e=null){const a=t.sampleRate,o=t.numberOfChannels,n=t.length,h=[];for(let r=0;r<o;r++)h.push(t.getChannelData(r));this.analysisInProgress=!0;try{e&&e("Analyzing peak levels...",0);let r=0;for(let g=0;g<o;g++){const y=h[g];for(let u=0;u<n;u++){if(!this.analysisInProgress)throw new Error("Analysis cancelled");const S=Math.abs(y[u]);if(S>r&&(r=S),u%1e4===0){const M=(g*n+u)/(o*n)*.5;e&&e("Analyzing peak levels...",M),u%1e5===0&&await new Promise(U=>setTimeout(U,1))}}}const f=r>0?20*Math.log10(r):-1/0;e&&e("Analyzing noise floor...",.5);const c=await this.analyzeNoiseFloor(h,o,n,e),i=await this.analyzeNoiseFloorHistogram(h,o,n);e&&e("Checking normalization...",.9);const l=this.checkNormalization(f);e&&e("Estimating reverb...",.95);const s=await this.estimateReverb(h,o,n,a,i),p=this.interpretReverb(s);e&&e("Analyzing silence...",.98);const{leadingSilence:d,trailingSilence:w,longestSilence:m}=this.analyzeSilence(h,o,n,a,i,f);return e&&e("Analysis complete!",1),{peakDb:f,noiseFloorDb:c,noiseFloorDbHistogram:i,normalizationStatus:l,reverbInfo:p,leadingSilence:d,trailingSilence:w,longestSilence:m}}finally{this.analysisInProgress=!1}}interpretReverb(t){return t<=0?{time:t,label:"N/A",description:"No reverb detected."}:t<.3?{time:t,label:"Excellent (Dry)",description:"Ideal for voiceover. Matches a vocal booth or well-treated studio environment."}:t<.5?{time:t,label:"Good (Controlled)",description:"A well-controlled room with minimal reflections. Acceptable for most recording."}:t<.8?{time:t,label:"Fair (Slightly Live)",description:"Noticeable room reflections. May reduce clarity for voiceover work."}:t<1.2?{time:t,label:"Poor (Reverberant)",description:"Significant reverb is present, making the recording sound distant and unprofessional."}:{time:t,label:"Very Poor (Echoey)",description:"Excessive echo and reverb. Unsuitable for professional voice recording."}}analyzeSilence(t,e,a,o,n,h){const r=h-n,f=.25,c=Math.max(0,r),i=n+c*f,l=Math.pow(10,i/20),s=50,p=Math.floor(o*(s/1e3)),d=Math.ceil(a/p),m=Math.ceil(150/s),g=new Array(d).fill(0);for(let b=0;b<d;b++){const k=b*p,C=Math.min(k+p,a);let F=0;for(let W=0;W<e;W++){const I=t[W];for(let x=k;x<C;x++){const T=Math.abs(I[x]);T>F&&(F=T)}}F>l&&(g[b]=1)}let y=0;for(let b=0;b<d;b++)if(g[b]===1)y++;else{if(y>0&&y<m)for(let k=1;k<=y;k++)g[b-k]=0;y=0}if(y>0&&y<m)for(let b=1;b<=y;b++)g[d-b]=0;let u=0,S=0;for(let b=0;b<d;b++)g[b]===0?S++:(S>u&&(u=S),S=0);S>u&&(u=S);const M=u*(s/1e3),U=g.indexOf(1),D=g.lastIndexOf(1);let z=0,A=0;return U===-1?(z=a/o,A=a/o):(z=U*(s/1e3),A=(d-1-D)*(s/1e3)),{leadingSilence:z,trailingSilence:A,longestSilence:M}}async estimateReverb(t,e,a,o,n){const c=Math.floor(o*.02),i=-25;let l=[];const s=t[0];let p=0;for(let m=0;m<a-1024;m+=1024){let g=0;for(let u=m;u<m+1024;u++)g+=s[u]*s[u];const y=Math.sqrt(g/1024);if(y>p*1.5&&y>.01){let u=0,S=m;for(let U=m;U<m+1024;U++)Math.abs(s[U])>u&&(u=Math.abs(s[U]),S=U);const M=20*Math.log10(u);if(M>n+10){let U=-1;for(let D=S;D<a-c;D+=c){let z=0;for(let k=D;k<D+c;k++)z+=s[k]*s[k];const A=Math.sqrt(z/c);if((A>0?20*Math.log10(A):-120)<M+i){U=D;break}}if(U!==-1){const D=(U-S)/o;if(D>0){const z=D*(60/Math.abs(i));l.push(z)}}}}p=y}if(l.length<1)return 0;l.sort((m,g)=>m-g);const d=Math.floor(l.length/2);return l.length%2!==0?l[d]:(l[d-1]+l[d])/2}async analyzeNoiseFloorHistogram(t,e,a){const n=new Array(100).fill(0),h=-100,r=100,f=Math.floor(44100*.05);for(let s=0;s<e;s++){const p=t[s];for(let d=0;d<a;d+=f){const w=Math.min(d+f,a);let m=0;for(let u=d;u<w;u++)m+=p[u]*p[u];const g=Math.sqrt(m/(w-d)),y=g>0?20*Math.log10(g):h;if(y>=h){const u=Math.min(Math.floor((y-h)/r*100),99);n[u]++}}}let c=-1,i=0;for(let s=0;s<100;s++)n[s]>i&&(i=n[s],c=s);return c===-1?-1/0:c*(r/100)+h}async analyzeNoiseFloor(t,e,a,o){const n=Math.floor(a/100),h=[];for(let l=0;l<e;l++){const s=t[l];for(let p=0;p<a-n;p+=n){let d=0;for(let m=p;m<p+n&&m<a;m++)d+=s[m]*s[m];const w=Math.sqrt(d/n);h.push(w)}}h.sort((l,s)=>l-s);const r=Math.floor(h.length*.2),f=h.slice(0,r),c=f.reduce((l,s)=>l+s,0)/f.length;return c>0?20*Math.log10(c):-1/0}checkNormalization(t){let o,n;return Math.abs(t- -6)<=.1?(o="normalized",n="Properly normalized"):t>-6?(o="too_loud",n="Too loud"):(o="too_quiet",n="Too quiet"),{status:o,message:n,peakDb:t,targetDb:-6}}cancelAnalysis(){this.analysisInProgress=!1}analyzeStereoSeparation(t){if(t.numberOfChannels!==2)return null;const e=t.getChannelData(0),a=t.getChannelData(1),o=t.sampleRate,n=t.length,h=Math.floor(o*.25),r=1.1,f=.001;let c=0,i=0,l=0,s=0,p=0;for(let S=0;S<n;S+=h){let M=0,U=0;const D=Math.min(S+h,n),z=D-S;for(let C=S;C<D;C++)M+=e[C]*e[C],U+=a[C]*a[C];const A=Math.sqrt(M/z),b=Math.sqrt(U/z);if(p++,A<f&&b<f){s++;continue}const k=A/b;k>r?c++:k<1/r?i++:l++}const d=p-s;let w="Undetermined",m=0,g=0,y=0,u=0;return d>0?(u=l/d,g=c/d,y=i/d,u>.9?(w="Mono as Stereo",m=u):g>.1&&y>.1?(w="Conversational Stereo",m=g+y):g>.9?(w="Mono in Left Channel",m=g):y>.9?(w="Mono in Right Channel",m=y):(w="Mixed Stereo",m=1-u)):(w="Silent",m=1),{totalBlocks:p,activeBlocks:d,silentBlocks:s,leftDominantBlocks:c,rightDominantBlocks:i,balancedBlocks:l,stereoType:w,stereoConfidence:Math.min(m,1)}}}class B{async analyzeHeaders(t){const a=await t.slice(0,102400).arrayBuffer(),o=new DataView(a),n={filename:t.name,fileSize:t.size,fileType:this.getFileType(t.name)};if(t.name.toLowerCase().endsWith(".wav")){const h=this.parseWavHeaders(o,t.size);Object.assign(n,h),h.formatType&&(n.fileType=h.formatType)}else t.name.toLowerCase().endsWith(".mp3")?Object.assign(n,this.parseMp3Headers(o,t.size)):t.name.toLowerCase().endsWith(".flac")?Object.assign(n,this.parseFlacHeaders(o,t.size)):(n.sampleRate="Unknown",n.bitDepth="Unknown",n.channels="Unknown",n.duration="Unknown");return n}parseWavHeaders(t,e){try{if(String.fromCharCode(t.getUint8(0),t.getUint8(1),t.getUint8(2),t.getUint8(3))!=="RIFF")throw new Error("Not a valid WAV file");if(String.fromCharCode(t.getUint8(8),t.getUint8(9),t.getUint8(10),t.getUint8(11))!=="WAVE")throw new Error("Not a valid WAV file");let n=12;for(;n<t.byteLength-8;){const h=String.fromCharCode(t.getUint8(n),t.getUint8(n+1),t.getUint8(n+2),t.getUint8(n+3)),r=t.getUint32(n+4,!0);if(h==="fmt "){const f=t.getUint16(n+8,!0),c=t.getUint16(n+10,!0),i=t.getUint32(n+12,!0),l=t.getUint16(n+22,!0),s=t.getUint32(n+16,!0),p=e-44,d=s>0?p/s:"Unknown";return{sampleRate:i,channels:c,bitDepth:l,duration:typeof d=="number"?d:"Unknown",audioFormat:f,formatType:f===1?"WAV (PCM)":`WAV (Format ${f})`}}n+=8+r}throw new Error("fmt chunk not found")}catch{return{sampleRate:"Unknown",channels:"Unknown",bitDepth:"Unknown",duration:"Unknown",formatType:"WAV"}}}parseMp3Headers(t){try{let e=0;for(;e<t.byteLength-4;){if(t.getUint8(e)===255&&(t.getUint8(e+1)&224)===224){const a=t.getUint32(e,!1),o=a>>19&3,n=a>>17&3,h=a>>12&15,r=a>>10&3,f=a>>6&3,c=[44100,48e3,32e3],i=f===3?1:2;return{sampleRate:c[r]||"Unknown",channels:i,bitDepth:"Compressed (variable)",duration:"Unknown"}}e++}throw new Error("No MP3 frame found")}catch{return{sampleRate:"Unknown",channels:"Unknown",bitDepth:"Compressed (variable)",duration:"Unknown"}}}parseFlacHeaders(t){try{if(String.fromCharCode(t.getUint8(0),t.getUint8(1),t.getUint8(2),t.getUint8(3))!=="fLaC")throw new Error("Not a valid FLAC file");const a=t.getUint8(4),o=(a&128)!==0;if((a&127)===0){const h=t.getUint16(5,!1),r=t.getUint16(7,!1),f=t.getUint16(18,!1),c=t.getUint8(20),i=f<<4|c>>4,l=(c>>1&7)+1,s=((c&1)<<4|t.getUint8(21)>>4)+1;return{sampleRate:i,channels:l,bitDepth:s,duration:"Unknown"}}throw new Error("STREAMINFO block not found")}catch{return{sampleRate:"Unknown",channels:"Unknown",bitDepth:"Unknown",duration:"Unknown"}}}getFileType(t){const e=t.split(".").pop().toLowerCase();return{wav:"WAV",mp3:"MP3",flac:"FLAC",aac:"AAC",m4a:"M4A",ogg:"OGG"}[e]||e.toUpperCase()}}class P{constructor(t){this.analyzer=new B,this.validator=t,this.cancelled=!1}async processBatch(t,e,a,o){this.cancelled=!1;const n=[],h=Date.now();for(let r=0;r<t.length&&!this.cancelled;r++){const f=t[r];let c;try{const i=await this.analyzer.analyzeHeaders(f),l=typeof e=="function"?e():e,s=this.validator.validateResults(i,l);c={filename:f.name,file:f,analysis:i,validation:s,status:this.getOverallStatus(s)}}catch(i){c={filename:f.name,file:f,analysis:null,validation:null,status:"error",error:i.message}}n.push(c),o&&o(c),a&&a({current:r+1,total:t.length,currentFile:f.name,percentage:(r+1)/t.length*100,elapsedTime:Date.now()-h})}return n}getOverallStatus(t){const e=Object.values(t).map(a=>a.status);return e.includes("fail")?"fail":e.includes("warning")?"warning":"pass"}cancel(){this.cancelled=!0}}export{H as A,P as B,V as C,L};
